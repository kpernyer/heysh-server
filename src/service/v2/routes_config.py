"""Configuration API routes with proper content negotiation."""

from typing import Any, Dict

import structlog
from fastapi import APIRouter, Header, HTTPException, Request, status
from fastapi.responses import JSONResponse, Response

from src.service.config import get_settings

logger = structlog.get_logger()

router = APIRouter(prefix="/api/v2/config", tags=["Configuration"])


def get_frontend_configuration() -> Dict[str, Any]:
    """Get the frontend configuration data."""
    settings = get_settings()

    # Build configuration object
    config = {
        "api": {
            "baseUrl": settings.api_url,
            "version": "v2",
            "timeout": 30000
        },
        "supabase": {
            "url": settings.supabase_url,
            "anonKey": settings.supabase_anon_key,
        },
        "features": {
            "authentication": True,
            "realtime": True,
            "fileUpload": True,
            "workflows": True,
            "digitalTwins": True,
            "aiAssistant": getattr(settings, "ai_features_enabled", True)
        },
        "ui": {
            "theme": "light",
            "locale": "en",
            "dateFormat": "YYYY-MM-DD",
            "timeFormat": "24h"
        },
        "limits": {
            "maxFileSize": 104857600,  # 100MB
            "maxFilesPerUpload": 10,
            "maxTopicsPerUser": 100,
            "maxMembersPerTopic": 1000
        },
        "environment": settings.environment,
        "debug": settings.debug
    }

    return config


@router.get("/frontend")
async def get_frontend_config(
    request: Request,
    accept: str = Header(None, alias="Accept")
) -> Response:
    """Get frontend configuration with content negotiation.

    Supports:
    - application/json (default): Returns JSON configuration
    - application/javascript: Returns configuration as JavaScript module
    - text/javascript: Returns configuration as JavaScript global
    """
    try:
        config_data = get_frontend_configuration()

        # Parse Accept header to determine response format
        if accept:
            accept_types = [a.strip().split(';')[0] for a in accept.split(',')]
        else:
            accept_types = ["application/json"]

        # Determine response format based on Accept header
        for accept_type in accept_types:
            if accept_type in ["application/javascript", "text/javascript", "*/*"]:
                # Return as JavaScript
                config_js = generate_javascript_config(config_data,
                                                       module_format=(accept_type == "application/javascript"))
                return Response(
                    content=config_js,
                    media_type="application/javascript" if accept_type == "application/javascript" else "text/javascript",
                    headers={
                        "Cache-Control": "public, max-age=3600",  # Cache for 1 hour
                        "X-Content-Type-Options": "nosniff"
                    }
                )
            elif accept_type in ["application/json", "text/json"]:
                # Return as JSON (default)
                return JSONResponse(
                    content=config_data,
                    headers={
                        "Cache-Control": "public, max-age=3600",  # Cache for 1 hour
                    }
                )

        # Default to JSON if no match
        return JSONResponse(
            content=config_data,
            headers={
                "Cache-Control": "public, max-age=3600",
            }
        )

    except Exception as e:
        logger.error("Failed to get frontend configuration", error=str(e))
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Failed to get frontend configuration: {e}"
        )


def generate_javascript_config(config: Dict[str, Any], module_format: bool = True) -> str:
    """Generate JavaScript configuration.

    Args:
        config: Configuration dictionary
        module_format: If True, export as ES6 module. If False, set as global variable.
    """
    import json

    config_json = json.dumps(config, indent=2)

    if module_format:
        # ES6 module format (for modern bundlers)
        js_content = f"""// Frontend Configuration - Generated by API v2
// This file is auto-generated. Do not edit manually.

const config = {config_json};

// Helper functions
export function getApiUrl(endpoint) {{
  return `${{config.api.baseUrl}}${{endpoint}}`;
}}

export function getSupabaseUrl() {{
  return config.supabase.url;
}}

export function getSupabaseAnonKey() {{
  return config.supabase.anonKey;
}}

export function isFeatureEnabled(feature) {{
  return config.features[feature] || false;
}}

export function getEnvironment() {{
  return config.environment;
}}

// Export configuration
export default config;
export {{ config }};
"""
    else:
        # Global variable format (for legacy/CDN usage)
        js_content = f"""// Frontend Configuration - Generated by API v2
// This file is auto-generated. Do not edit manually.

(function(window) {{
  'use strict';

  const config = {config_json};

  // Helper functions
  const helpers = {{
    getApiUrl: function(endpoint) {{
      return config.api.baseUrl + endpoint;
    }},

    getSupabaseUrl: function() {{
      return config.supabase.url;
    }},

    getSupabaseAnonKey: function() {{
      return config.supabase.anonKey;
    }},

    isFeatureEnabled: function(feature) {{
      return config.features[feature] || false;
    }},

    getEnvironment: function() {{
      return config.environment;
    }}
  }};

  // Expose to global scope
  window.APP_CONFIG = config;
  window.APP_CONFIG_HELPERS = helpers;

  // For compatibility with require() systems
  if (typeof module !== 'undefined' && module.exports) {{
    module.exports = config;
  }}
}})(typeof window !== 'undefined' ? window : this);
"""

    return js_content


@router.get("/environment")
async def get_environment_config() -> Dict[str, Any]:
    """Get environment-specific configuration.

    Returns minimal configuration about the current environment.
    """
    settings = get_settings()

    return {
        "environment": settings.environment,
        "api_version": "v2",
        "api_url": settings.api_url,
        "debug": settings.debug,
        "cors_origins": settings.cors_origins,
    }


@router.get("/features")
async def get_feature_flags() -> Dict[str, bool]:
    """Get feature flags for the current environment.

    Returns which features are enabled/disabled.
    """
    settings = get_settings()

    return {
        "authentication": True,
        "realtime": True,
        "fileUpload": True,
        "workflows": True,
        "digitalTwins": True,
        "aiAssistant": getattr(settings, "ai_features_enabled", True),
        "advancedSearch": True,
        "collaborativeEditing": False,  # Future feature
        "videoConferencing": False,  # Future feature
        "mobileApp": False,  # Future feature
    }


@router.get("/limits")
async def get_system_limits() -> Dict[str, Any]:
    """Get system limits and quotas.

    Returns limits for various operations.
    """
    return {
        "uploads": {
            "maxFileSize": 104857600,  # 100MB
            "maxFilesPerUpload": 10,
            "allowedMimeTypes": [
                "application/pdf",
                "text/plain",
                "text/markdown",
                "text/html",
                "image/jpeg",
                "image/png",
                "image/gif",
                "video/mp4",
                "audio/mpeg"
            ]
        },
        "topics": {
            "maxPerUser": 100,
            "maxMembersPerTopic": 1000,
            "maxDocumentsPerTopic": 10000
        },
        "workflows": {
            "maxConcurrentExecutions": 10,
            "maxExecutionTime": 3600,  # 1 hour
            "maxRetries": 3
        },
        "api": {
            "rateLimitPerMinute": 100,
            "rateLimitPerHour": 1000,
            "maxRequestSize": 10485760  # 10MB
        }
    }